---
title: MoveTo
second_title: Referencia de API de GroupDocs.Parser para .NET
description: Crea un nuevo diseño con el mismo tamaño separadores y posición en elpoint .
type: docs
weight: 50
url: /es/net/groupdocs.parser.templates/templatetablelayout/moveto/
---
## TemplateTableLayout.MoveTo method

Crea un nuevo diseño con el mismo tamaño, separadores y posición en el*point* .

```csharp
public TemplateTableLayout MoveTo(Point point)
```

| Parámetro | Escribe | Descripción |
| --- | --- | --- |
| point | Point | La posición del nuevo diseño. |

### Valor_devuelto

Un nuevo diseño con el mismo tamaño, separadores y posición en el*point*.

### Ejemplos

Esta funcionalidad permite mover Table Layout.

Por ejemplo, un documento tiene tablas en cada página (o un conjunto de documentos con una tabla en la página). Estas tablas se diferencian por su posición y contenido, pero tienen las mismas columnas y filas. En este caso, un usuario puede definir [`TemplateTableLayout`](../../templatetablelayout) objeto en`(0, 0)` una vez y luego muévalo a la ubicación de la tabla definitiva.

Si la posición de la tabla depende del otro objeto de la página, un usuario puede definir[`TemplateTableLayout`](../../templatetablelayout) objeto basado en en el documento de plantilla y luego muévalo de acuerdo con un objeto de anclaje. Por ejemplo, si se trata de una tabla de resumen y , le sigue una tabla de detalles (que puede contener un número diferente de filas). En este caso, un usuario puede definir [`TemplateTableLayout`](../../templatetablelayout)objeto en el documento de plantilla (con el rectángulo de la tabla de detalles conocidos) y luego mueva [`TemplateTableLayout`](../../templatetablelayout) objeto según la diferencia de detalles tabla rectángulo de plantilla y documento real.

`MoveTo` método devuelve una copia del objeto actual. Un usuario puede pasar cualquier coordenada (incluso negativa, luego el diseño se moverá hacia la izquierda/arriba).

```csharp
// Crear un diseño de mesa
TemplateTableLayout layout = new TemplateTableLayout(
    new double[] { 0, 25, 150, 180, 230 },
    new double[] { 0, 15, 30, 45, 60, 75 });

// Imprime un rectángulo
Rectangle rect = layout.Rectangle;

// Imprime: pos: (0, 0) tamaño: (230, 75)
Console.WriteLine(string.Format("pos: ({0}, {1}) size: ({2}, {3})", rect.Left, rect.Top, rect.Size.Width, rect.Size.Height));

// Mueve el diseño a la ubicación definitiva de la tabla
TemplateTableLayout movedLayout = layout.MoveTo(new Point(315, 250));

// Asegúrese de que los primeros separadores se muevan:
Console.WriteLine(movedLayout.VerticalSeparators[0]); // imprime: 315
Console.WriteLine(movedLayout.HorizontalSeparators[0]); // impresiones: 250

Rectangle movedRect = movedLayout.Rectangle;

// Imprime: pos: (315, 250) tamaño: (230, 75)
Console.WriteLine(string.Format("pos: ({0}, {1}) size: ({2}, {3})", movedRect.Left, movedRect.Top, movedRect.Size.Width, movedRect.Size.Height));

// El objeto MoveLayout es una copia del objeto de diseño, por lo que podemos ajustar los separadores sin afectar el diseño original:
movedLayout.HorizontalSeparators.Add(90);

Console.WriteLine(movedLayout.HorizontalSeparators.Count); // imprime: 7
Console.WriteLine(layout.HorizontalSeparators.Count); // imprime: 6
```

### Ver también

* class [Point](../../../groupdocs.parser.data/point)
* class [TemplateTableLayout](../../templatetablelayout)
* espacio de nombres [GroupDocs.Parser.Templates](../../templatetablelayout)
* asamblea [GroupDocs.Parser](../../../)

<!-- DO NOT EDIT: generated by xmldocmd for GroupDocs.Parser.dll -->
